#GEEcode

var table = ee.FeatureCollection('projects/gee-python-456606/assets/StudyArea');
var geometry = table.geometry();

// Parameters
var startDate = '2023-12-01';
var endDate   = '2024-11-30';
var cloudCoverMax = 10;

// Cloud mask
var maskClouds = function(image) {
  var qa = image.select('QA_PIXEL');
  var mask = qa.bitwiseAnd(1 << 3).eq(0)     // Cloud
               .and(qa.bitwiseAnd(1 << 4).eq(0)) // Cloud Shadow
               .and(qa.bitwiseAnd(1 << 5).eq(0)) // Snow
               .and(qa.bitwiseAnd(1 << 1).eq(0)); // Dilated Cloud
  return image.updateMask(mask);
};

// Convert to celsius
var addLST = function(image) {
  var lstK = image.select('ST_B10').multiply(0.00341802).add(149.0);
  var lstC = lstK.subtract(273.15).rename('LST_Celsius');
  return image.addBands(lstC);
};

// Image collection
var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
  .merge(ee.ImageCollection('LANDSAT/LC09/C02/T1_L2'))
  .filterDate(startDate, endDate)
  .filterBounds(geometry)
  .filter(ee.Filter.lt('CLOUD_COVER', cloudCoverMax))
  .map(maskClouds)
  .map(addLST)
  .select('LST_Celsius');

// Annual average
var lstMean = collection.mean().clip(geometry);

// Display the main map
Map.centerObject(geometry, 10);
Map.addLayer(lstMean, {min:5, max:50, palette:['blue','cyan','green','yellow','orange','red']}, 
             'LST mean (°C)');

// Overall statistics
var stats = lstMean.reduceRegion({
  reducer: ee.Reducer.mean().combine(ee.Reducer.minMax(), '', true)
                         .combine(ee.Reducer.stdDev(), '', true),
  geometry: geometry,
  scale: 30,
  maxPixels: 1e13,
  bestEffort: true
});

print('════════════════════════════════');
print('LST mean :', ee.Number(stats.get('LST_Celsius_mean')).format('%.2f'), '°C');
print('Minimum LST : ', ee.Number(stats.get('LST_Celsius_min')).format('%.2f'), '°C');
print('Maximum LST :', ee.Number(stats.get('LST_Celsius_max')).format('%.2f'), '°C');
print('Standard deviation :', ee.Number(stats.get('LST_Celsius_stdDev')).format('%.2f'), '°C');
print('════════════════════════════════');

// ================== Finding the hottest and coldest pixels ==================

var maxTemp = ee.Number(stats.get('LST_Celsius_max'));
var minTemp = ee.Number(stats.get('LST_Celsius_min'));

var hotMask  = lstMean.eq(maxTemp);
var coldMask = lstMean.eq(minTemp);


var hotPoints = hotMask.selfMask().reduceToVectors({
  geometry: geometry,
  scale: 30,
  geometryType: 'centroid',
  maxPixels: 1e13
}).map(function(f) {
  return f.set({Type: 'Warmest point', LST_C: maxTemp.format('%.2f')});
});

var coldPoints = coldMask.selfMask().reduceToVectors({
  geometry: geometry,
  scale: 30,
  geometryType: 'centroid',
  maxPixels: 1e13
}).map(function(f) {
  return f.set({Type: 'Coldest point ', LST_C: minTemp.format('%.2f')});
});


var hotFC  = ee.FeatureCollection(hotPoints.limit(1));   //  FeatureCollection
var coldFC = ee.FeatureCollection(coldPoints.limit(1));  //  FeatureCollection

var extremePoints = hotFC.merge(coldFC);  


Map.addLayer(hotFC.style({
  color: 'red',
  fillColor: 'red',
  width: 5,
  pointSize: 20
}), {}, 'Warmest point');

Map.addLayer(coldFC.style({
  color: 'cyan',
  fillColor: 'cyan',
  width: 5,
  pointSize: 20
}), {}, 'Coldest point');


Map.addLayer(extremePoints.style({
  pointSize: 18,
  width: 4,
  color: 'white',
  fillColor: 'black'
}), {}, 'نقاط اکستریم');

// ================== Export and print ==================
print('Warmest point:', hotPoints.first());
print('Coldest point:', coldPoints.first());
print('(FeatureCollection):', extremePoints);

// Export to Shapefile
Export.table.toDrive({
  collection: extremePoints,
  description: 'LST_Extreme_Points_StudyArea',
  folder: 'GEE_LST',
  fileNamePrefix: 'Hottest_and_Coldest_Points',
  fileFormat: 'SHP'
});

// Export mean
Export.image.toDrive({
  image: lstMean.toFloat(),
  description: 'LST_Annual_Mean_StudyArea',
  folder: 'GEE_LST',
  region: geometry,
  scale: 30,
  maxPixels: 1e13,
  crs: 'EPSG:4326',
  fileFormat: 'GeoTIFF'
});
